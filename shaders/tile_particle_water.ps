#if defined( GL_ES )
precision mediump float;
#endif

uniform sampler2D SAMPLER[4];

varying vec3 PS_TEXCOORD_LIFE;
varying vec4 PS_COLOUR;

#ifndef LIGHTING_H
#define LIGHTING_H

#if !defined( UI_CC )
// Lighting
varying vec3 PS_POS;
#endif

// xy = min, zw = max
uniform vec4 LIGHTMAP_WORLD_EXTENTS;

#define LIGHTMAP_TEXTURE SAMPLER[3]

#ifndef LIGHTMAP_TEXTURE
	#error If you use lighting, you must #define the sampler that the lightmap belongs to
#endif

#if defined( UI_CC )
vec3 CalculateLightingContribution(vec2 pos)
{
	vec2 uv = ( pos - LIGHTMAP_WORLD_EXTENTS.xy ) * LIGHTMAP_WORLD_EXTENTS.zw;
	return texture2D( LIGHTMAP_TEXTURE, uv.xy ).rgb;
}
#else
vec3 CalculateLightingContribution()
{
	vec2 uv = ( PS_POS.xz - LIGHTMAP_WORLD_EXTENTS.xy ) * LIGHTMAP_WORLD_EXTENTS.zw;
	return texture2D( LIGHTMAP_TEXTURE, uv.xy ).rgb;
}

vec3 CalculateLightingContribution( vec3 normal )
{
	return vec3( 1, 1, 1 );
}
#endif

#endif //LIGHTING.h

// 简单的伪随机数生成器
float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

// 简单的2D噪声函数（基于随机值插值）
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    
    // 四个角点的随机值
    float a = rand(i);
    float b = rand(i + vec2(1.0, 0.0));
    float c = rand(i + vec2(0.0, 1.0));
    float d = rand(i + vec2(1.0, 1.0));
    
    // 平滑插值
    vec2 u = f * f * (3.0 - 2.0 * f);
    
    // 双线性插值
    return mix(a, b, u.x) + 
           (c - a) * u.y * (1.0 - u.x) + 
           (d - b) * u.x * u.y;
}

// 分形噪声（多层级噪声叠加）
float fbm(vec2 p) {
    float value = 0.0;
    float amplitude = 0.5;
    
    for (int i = 0; i < 4; i++) {
        value += amplitude * noise(p);
        p *= 2.5;
        amplitude *= 0.5;
    }
    
    return value;
}

const float size = 0.2; // 该值越大，扭曲细节的尺度越小
const float strength = 1.0; // 该值越大，纹理扭曲的力度越大

void main()
{
	float time = PS_TEXCOORD_LIFE.z * 1000000000.0;
	vec2 new_uv = PS_POS.xz;
    // 计算旋转角度（随时间变化）
    float rotation_angle = time; // 控制旋转速度，可根据需要调整
    
    // 创建旋转矩阵
    mat2 rotation_matrix = mat2(
        cos(rotation_angle), -sin(rotation_angle),
        sin(rotation_angle), cos(rotation_angle)
    );

    new_uv += rotation_matrix * vec2(
    	fbm(new_uv * size + time * 0.5) - 0.5,
    	0.0
    ) * strength;

    new_uv += rotation_matrix * vec2(
    	fbm(new_uv * size + - time * 0.5 + vec2(10.0)) - 0.5,
        0.0
    ) * strength;

	float noise_x = mod(new_uv.x, 29.0) * 0.0344827586 * 0.25 + 0.0078125;
	float noise_z = mod(new_uv.y, 29.0) * 0.0344827586 * 0.25 + 0.0078125;
	vec2 noise_texcoord = vec2(noise_x, noise_z);
	vec4 colour = texture2D( SAMPLER[0], PS_TEXCOORD_LIFE.xy );
	vec4 colour2 = texture2D( SAMPLER[0], noise_texcoord.xy );
	gl_FragColor = vec4( colour.rgb * PS_COLOUR.rgb * colour2.rgb * colour.a , colour.a * PS_COLOUR.a * colour2.a );

	vec3 light = CalculateLightingContribution();

	gl_FragColor.rgb *= light;
}